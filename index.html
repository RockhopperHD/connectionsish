<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connectionsish Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-bg: #121212;
            --color-tile: #2c2c2c;
            --color-tile-selected: #5a5a5a;
            --color-text: #ffffff;
            --color-button: #4a4a4a;
            --color-button-hover: #5a5a5a;
            --color-mistake: #4a4a4a;
            --color-mistake-used: #2c2c2c;
            --font-family: 'Inter', sans-serif;
            
            --cat-yellow: #f9df6d;
            --cat-green: #a0c35a;
            --cat-blue: #b0c4ef;
            --cat-purple: #d0b0ef;

            --sprinkle-color-off: #1a1a1a;
        }

        body {
            background-color: var(--color-bg);
            color: var(--color-text);
            font-family: var(--font-family);
            margin: 0;
            text-align: center;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        #background-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1; transition: opacity 0.5s ease-in-out;
        }

        .sprinkle {
            position: absolute; width: 80px; height: 20px;
            border-radius: 10px; background-color: var(--sprinkle-color-off);
            transform: rotate(var(--rotation));
            transition: background-color 1s ease-in-out;
        }

        .screen {
            width: 100%; max-width: 500px; min-height: 100vh; padding: 2rem 1rem;
            box-sizing: border-box; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 10; margin: 0 auto;
        }

        h1 { font-size: 2.5rem; font-weight: 700; }
        .ish {
            background: linear-gradient(90deg, var(--cat-yellow) 0%, var(--cat-green) 33%, var(--cat-blue) 66%, var(--cat-purple) 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text; color: transparent;
        }

        h2 { font-size: 1.5rem; font-weight: 600; }
        p { color: #ccc; max-width: 400px; }
        
        #about-screen p, #about-screen .q-a-answer { text-align: left; }
        #about-screen a { color: #b0c4ef; }

        .game-wrapper {
            position: relative; width: 100%; max-width: 700px; min-height: 100vh;
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; box-sizing: border-box; padding: 1rem; margin: 0 auto;
        }
        .game-container { width: 100%; margin: auto; box-sizing: border-box; }
        #puzzle-info { margin-bottom: 8px; font-weight: bold; height: 18px; font-size: 0.9rem; text-align: center; }
        .info-tooltip-container { position: relative; display: inline-block; }
        .info-icon {
            display: inline-flex; justify-content: center; align-items: center;
            width: 16px; height: 16px; border-radius: 50%;
            background-color: #666; color: var(--color-bg);
            font-size: 12px; font-style: italic; font-weight: bold; cursor: pointer;
            margin-left: 5px;
        }
        .info-tooltip-text {
            visibility: hidden; width: 220px; background-color: #333; color: #fff;
            text-align: center; border-radius: 6px; padding: 8px;
            position: absolute; z-index: 1; bottom: 125%; left: 50%;
            margin-left: -110px; opacity: 0; transition: opacity 0.3s;
            font-size: 0.8rem; font-weight: normal;
        }
        .info-tooltip-container:hover .info-tooltip-text { visibility: visible; opacity: 1; }
        #game-prompt {
            margin-top: 0; margin-bottom: 12px; height: 20px; color: #fff; text-align: center;
        }

        #gameCanvas { width: 100%; height: auto; aspect-ratio: 5 / 3; border-radius: 8px; cursor: pointer; touch-action: none; }
        .info-panel { margin-top: 1rem; width: 100%; }

        #message-box {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: rgba(0,0,0,0.8); color: white; padding: 10px 20px;
            border-radius: 20px; z-index: 200; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s;
        }
        #message-box.show { opacity: 1; visibility: visible; }

        #mistakes-container {
            display: flex; gap: 8px; justify-content: center; align-items: center; margin-bottom: 1rem;
        }
        .mistake-dot {
            width: 16px; height: 16px; background-color: var(--color-mistake);
            border-radius: 50%; transition: background-color 0.3s ease;
        }
        .mistake-dot.used { background-color: var(--color-mistake-used); }

        .controls, .play-controls-main, .maker-controls, .results-controls {
            display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; 
        }

        .play-controls { margin-top: 25px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #play-screen .menu-btn { font-size: 1rem; }
        .small-btn { font-size: 0.8rem !important; padding: 6px 16px !important; margin-top: 20px !important; }
        .results-controls { margin-top: 2rem; }

        .control-btn, .menu-btn {
            background-color: var(--color-button); color: var(--color-text); border: none;
            padding: 12px 24px; border-radius: 50px; font-size: 1.1rem; font-weight: 600;
            cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; margin: 5px;
        }
        .control-btn:hover, .menu-btn:hover { background-color: var(--color-button-hover); }
        .control-btn:active, .menu-btn:active { transform: scale(0.95); }
        
        .maker-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; width: 100%; margin-bottom: 1rem; }
        .category-inputs { display: grid; grid-template-columns: 1fr; gap: 8px; width: 100%; margin-bottom: 1.5rem; }
        .maker-input {
            width: 100%; padding: 10px; background-color: var(--color-tile);
            border: 1px solid var(--color-button); border-left-width: 4px;
            color: var(--color-text); border-radius: 6px; font-family: var(--font-family);
            font-size: 0.9rem; box-sizing: border-box; text-align: center; transition: border-color 0.2s;
        }
        .maker-input.category-0 { border-left-color: var(--cat-yellow); }
        .maker-input.category-1 { border-left-color: var(--cat-green); }
        .maker-input.category-2 { border-left-color: var(--cat-blue); }
        .maker-input.category-3 { border-left-color: var(--cat-purple); }
        
        textarea.maker-input {
            height: 120px; resize: none; font-size: 0.8rem; text-align: left;
            white-space: pre; overflow-wrap: normal; overflow-x: scroll; border-left-width: 1px;
        }
        #optional-fields { display: none; width: 100%; gap: 10px; }
        
        #history-panel {
            position: fixed; top: 50%; right: 0; transform: translate(calc(100% - 25px), -50%);
            width: 180px; height: 300px; background-color: var(--color-tile);
            border-radius: 8px 0 0 8px; transition: transform 0.3s ease-in-out;
            z-index: 50; display: flex; align-items: center;
        }
        @media (hover: hover) { #history-panel:hover { transform: translate(0, -50%); } }
        #history-panel.is-open { transform: translate(0, -50%); }
        #history-tab {
            width: 25px; height: 100%; cursor: pointer; display: flex; align-items: center;
            justify-content: center; background-color: var(--color-button); border-radius: 8px 0 0 8px;
        }
        #history-tab svg { transform: rotate(180deg); }
        #history-content { padding: 10px; height: 100%; overflow-y: auto; flex-grow: 1; }
        .history-guess {
            margin-bottom: 10px; font-size: 0.8rem; text-align: left;
            background: #333; padding: 5px; border-radius: 4px; position: relative;
        }
        .history-guess.correct { background: #2a3a2a; }
        .history-guess .one-away-icon {
            position: absolute; top: 2px; right: 4px; font-size: 1.1rem;
            font-weight: bold; color: var(--cat-yellow);
        }

        #results-modal, #out-of-lives-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center;
            align-items: center; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s 0.3s; z-index: 100;
        }
        #results-modal.show, #out-of-lives-modal.show { opacity: 1; visibility: visible; transition-delay: 0s; }
        .results-content {
            background-color: var(--color-bg); padding: 2rem; border-radius: 12px;
            width: 90%; max-width: 400px; text-align: center;
            transform: scale(0.9); transition: transform 0.3s ease;
        }
        #results-modal.show .results-content, #out-of-lives-modal.show .results-content { transform: scale(1); }
        .results-grid { display: grid; gap: 5px; margin-top: 1rem; }
        .result-row { padding: 10px; border-radius: 4px; color: #000; text-align: center; }
        .result-row strong { display: block; font-size: 1rem; font-weight: 700; }
        .result-row span { font-size: 0.85rem; font-weight: 500; }

        .title-footer {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            font-size: 0.75rem; color: #888; width: 90%; text-align: center;
        }
        #about-btn {
            position: fixed; top: 15px; right: 15px; background-color: white; color: black; border: none;
            width: 40px; height: 40px; border-radius: 50%; font-size: 1.5rem; font-weight: 700;
            cursor: pointer; z-index: 101; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex; align-items: center; justify-content: center; line-height: 1;
        }
        #about-btn:hover { transform: scale(1.1); }
        
        .q-a-container { width: 100%; text-align: left; }
        .q-a-container details { margin-bottom: 10px; width: 100%; }
        .q-a-container summary {
            font-weight: bold; cursor: pointer; list-style: none; /* Hide default triangle */
            padding: 10px; background-color: #2c2c2c; border-radius: 5px;
            position: relative; padding-left: 30px;
        }
        .q-a-container summary::-webkit-details-marker { display: none; }
        .q-a-container summary::before {
            content: '>';
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%) rotate(0deg);
            transition: transform 0.2s ease-in-out;
        }
        .q-a-container details[open] > summary::before {
             transform: translateY(-50%) rotate(90deg);
        }
        .q-a-answer { padding: 15px; background-color: #1e1e1e; border-radius: 0 0 5px 5px; border-top: 1px solid #444; }

    </style>
</head>
<body>
    <div id="background-container"></div>

    <button id="about-btn" style="display: none;">?</button>
    <div id="message-box"></div>

    <!-- About Screen -->
    <div id="about-screen" class="screen" style="display: none;">
        <h2>About</h2>
        <p>This is a personal project that uses the concept of the popular word-grouping game from <a href="https://www.nytimes.com/games/connections" target="_blank" rel="noopener noreferrer"><i>The New York Times</i></a> with some simple tweaks and improvements -- and sharing!</p>
        <div class="q-a-container">
            <details>
                <summary>How do I play?</summary>
                <div class="q-a-answer">In Connectionsish, your goal is to make 4 groups of four by connecting terms together without knowing the theme. If you're close but missed one, you'll see a "One away..." notification. You have four "lives" to get it right. You can see your past guesses in the sidebar on the right.</div>
            </details>
            <details>
                <summary>How do I make a puzzle?</summary>
                <div class="q-a-answer">Go to the "Make" screen and fill out the four categories and the chart below. Click "Generate Code" and send that to someone else. They can paste it into the website and see your puzzle. The reason it looks jumbled is because it "ciphers" it (moves the letters over) so there's no spoilers.</div>
            </details>
             <details>
                <summary>Why does this exist?</summary>
                <div class="q-a-answer">This project demonstrates creating a polished game using AI tools, HTML, and a bit of creativity. It's a fun way to showcase web development skills. While other clones exist, this version has a unique import/export system and a sleek UI.</div>
            </details>
        </div>
        <p>
            <b>About the creator.</b>
            This game was created by Owen Whelan, a student with a passion for technology, language, and education. 
            <u><a href="https://www.owenwhelan.com" target="_blank" rel="noopener noreferrer">You can learn more on his website.</a></u>
        </p>
        <button id="about-back-btn" class="menu-btn">Back to Title</button>
    </div>

    <!-- Title Screen -->
    <div id="title-screen" class="screen">
        <div id="title-content-box">
            <h1>Connections<span class="ish">ish</span></h1>
            <p>Create, share, and play custom puzzles.</p>
            <div>
                <button id="make-btn" class="menu-btn">Make</button>
                <button id="play-btn" class="menu-btn">Play</button>
            </div>
        </div>
        <footer class="title-footer">
            <p>Disclaimer: This is an unofficial personal project inspired by the game from The New York Times. It is not affiliated with the NYT.</p>
        </footer>
    </div>
    
    <!-- Play Screen -->
    <div id="play-screen" class="screen" style="display: none;">
        <h2>Paste Puzzle Code</h2>
        <p>Make a puzzle and paste the puzzle code here, or get a puzzle code from someone else.</p>
        <p>You can also click "Use Default Set" to just test the game.</p>
        <p><i>You can also send others you games with a link</i></p>
        <textarea id="json-input" class="maker-input" placeholder="Paste your ciphered puzzle code here..."></textarea>
        <div class="play-controls">
            <div class="play-controls-main">
                 <button id="play-back-btn" class="menu-btn">Back</button>
                 <button id="start-game-btn" class="menu-btn">Start Game</button>
            </div>
             <button id="use-default-btn" class="menu-btn small-btn">Use Default Set</button>
        </div>
    </div>
    
    <!-- Make Screen -->
    <div id="make-screen" class="screen" style="display: none;">
        <h2>Create a Puzzle</h2>
        <p>Fill out the fields below. Click "Generate Code", then copy and paste to share the game with others.</p>
        <div id="maker-form" style="width: 100%;">
            <div class="category-inputs">
                <input type="text" class="maker-input" id="cat-0-name" placeholder="Category 1 Name (Easiest)">
                <input type="text" class="maker-input" id="cat-1-name" placeholder="Category 2 Name">
                <input type="text" class="maker-input" id="cat-2-name" placeholder="Category 3 Name">
                <input type="text" class="maker-input" id="cat-3-name" placeholder="Category 4 Name (Hardest)">
            </div>
            <div class="maker-grid">
                <!-- Grid will be populated by JS -->
            </div>
             <button id="add-title-btn" class="menu-btn small-btn" style="margin-bottom: 1rem;">Add Title/Author</button>
            <div id="optional-fields" class="play-controls-main" style="width: 100%; display: none; margin-bottom: 1rem;">
                 <input type="text" class="maker-input" id="puzzle-title" placeholder="Puzzle Title">
                 <input type="text" class="maker-input" id="puzzle-author" placeholder="Author Name (Optional)">
            </div>
        </div>
         <textarea id="json-output" class="maker-input" readonly placeholder="Your generated puzzle code will appear here..."></textarea>
         <textarea id="url-output" class="maker-input" readonly placeholder="Your shareable link will appear here..." style="display: none; margin-top: 8px;"></textarea>
        <div class="maker-controls">
             <button id="make-back-btn" class="menu-btn">Back</button>
            <button id="generate-json-btn" class="menu-btn">Generate Code</button>
            <button id="copy-code-btn" class="menu-btn">Copy Code</button>
            <button id="copy-link-btn" class="menu-btn" style="display: none;">Copy Link</button>
        </div>
    </div>

    <!-- Game Wrapper -->
    <div class="game-wrapper" style="display: none;">
        <div class="game-container">
            <div id="puzzle-info"></div>
            <p id="game-prompt"></p>
            <canvas id="gameCanvas"></canvas>
            <div class="info-panel">
                <div id="mistakes-container">
                    <span>Mistakes remaining:</span>
                </div>
                <div class="controls">
                    <button class="control-btn" id="shuffle-btn">Shuffle</button>
                    <button class="control-btn" id="deselect-btn">Deselect all</button>
                    <button class="control-btn" id="submit-btn">Submit</button>
                </div>
            </div>
        </div>
    </div>
    
     <div id="history-panel" style="display: none;">
        <div id="history-tab">
            <svg width="8" height="12" viewBox="0 0 8 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M7.41 1.41L2.83 6L7.41 10.59L6 12L0 6L6 0L7.41 1.41Z" fill="white"/>
            </svg>
        </div>
        <div id="history-content"></div>
    </div>
    
    <!-- Results Modal -->
    <div id="results-modal">
        <div class="results-content">
            <h2 id="results-title"></h2>
            <p id="results-message"></p>
            <div id="results-grid" class="results-grid"></div>
            <div class="results-controls">
                <button class="control-btn" id="copy-results-btn">Share</button>
                <button class="control-btn" id="play-again-btn">New Game</button>
            </div>
        </div>
    </div>
    
    <!-- Out of Lives Modal -->
    <div id="out-of-lives-modal">
        <div class="results-content">
            <h2>Out of lives!</h2>
            <p>You can keep playing, but it will count against your score.</p>
            <div class="results-controls">
                <button id="continue-playing-btn" class="menu-btn">Continue Playing</button>
                <button id="reveal-answers-btn" class="menu-btn">Reveal Answers</button>
            </div>
        </div>
    </div>

    <script>
        // --- Game Data (will be loaded dynamically) ---
        let gameData = null;
        const DEFAULT_GAME_DATA = {
            categories: [
                { level: 0, name: "STARTS WITH 'A'", words: ["APPLE", "ANT", "ART", "AIM"] },
                { level: 1, name: "STARTS WITH 'B'", words: ["BALL", "BAT", "BOX", "BUG"] },
                { level: 2, name: "STARTS WITH 'C'", words: ["CAT", "CUP", "CAR", "COIN"] },
                { level: 3, name: "STARTS WITH 'D'", words: ["DOG", "DUCK", "DOLL", "DRUM"] }
            ]
        };

        // --- DOM Elements ---
        const backgroundContainer = document.getElementById('background-container');
        const titleScreen = document.getElementById('title-screen');
        const playScreen = document.getElementById('play-screen');
        const makeScreen = document.getElementById('make-screen');
        const aboutScreen = document.getElementById('about-screen');
        const gameWrapper = document.querySelector('.game-wrapper');
        const puzzleInfo = document.getElementById('puzzle-info');
        const gamePrompt = document.getElementById('game-prompt');
        
        const playBtn = document.getElementById('play-btn');
        const makeBtn = document.getElementById('make-btn');
        const aboutBtn = document.getElementById('about-btn');
        const playBackBtn = document.getElementById('play-back-btn');
        const makeBackBtn = document.getElementById('make-back-btn');
        const aboutBackBtn = document.getElementById('about-back-btn');
        const startGameBtn = document.getElementById('start-game-btn');
        const useDefaultBtn = document.getElementById('use-default-btn');
        const generateJsonBtn = document.getElementById('generate-json-btn');
        const copyCodeBtn = document.getElementById('copy-code-btn');
        const copyLinkBtn = document.getElementById('copy-link-btn');
        const makerGrid = document.querySelector('#make-screen .maker-grid');
        const jsonInput = document.getElementById('json-input');
        const jsonOutput = document.getElementById('json-output');
        const urlOutput = document.getElementById('url-output');
        const addTitleBtn = document.getElementById('add-title-btn');
        const optionalFields = document.getElementById('optional-fields');
        const puzzleTitleInput = document.getElementById('puzzle-title');
        const puzzleAuthorInput = document.getElementById('puzzle-author');

        const outOfLivesModal = document.getElementById('out-of-lives-modal');
        const continuePlayingBtn = document.getElementById('continue-playing-btn');
        const revealAnswersBtn = document.getElementById('reveal-answers-btn');

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('message-box');
        const mistakesContainer = document.getElementById('mistakes-container');
        const shuffleBtn = document.getElementById('shuffle-btn');
        const deselectBtn = document.getElementById('deselect-btn');
        const submitBtn = document.getElementById('submit-btn');
        const historyPanel = document.getElementById('history-panel');
        const historyTab = document.getElementById('history-tab');
        const historyContent = document.getElementById('history-content');
        const resultsModal = document.getElementById('results-modal');
        const resultsTitle = document.getElementById('results-title');
        const resultsMessage = document.getElementById('results-message');
        const resultsGrid = document.getElementById('results-grid');
        const playAgainBtn = document.getElementById('play-again-btn');
        const copyResultsBtn = document.getElementById('copy-results-btn');

        // --- Game State ---
        let tiles = [];
        let selectedTiles = [];
        let solvedCategories = [];
        let mistakesLeft = 4;
        let extraMistakes = 0;
        let isEndlessMode = false;
        let isAnimating = false;
        let guessHistory = [];
        let emojiHistory = [];
        let sprinkleInterval = null;
        
        const GRID_SIZE = 4;
        const TILE_GAP = 10;
        const TILE_ROUNDING = 8;
        const FONT_SIZE_FACTOR = 0.24;
        const MIN_FONT_SIZE = 10;

        const CATEGORY_COLORS = {
            0: '--cat-yellow', 1: '--cat-green', 2: '--cat-blue', 3: '--cat-purple'
        };
        const COLOR_VALUES = Object.values(CATEGORY_COLORS);

        // --- Navigation ---
        function showScreen(screenId) {
            document.querySelectorAll('.screen, .game-wrapper, #history-panel').forEach(el => {
                el.style.display = 'none';
            });
            const screen = document.getElementById(screenId);
            if (screen) screen.style.display = 'flex';
            
            if (screenId === 'game-wrapper') {
                 document.querySelector('.game-wrapper').style.display = 'flex';
                 document.getElementById('history-panel').style.display = 'flex';
            }
            
            if (screenId === 'title-screen') {
                backgroundContainer.style.opacity = '1';
                startSprinkleEffect();
                aboutBtn.style.display = 'flex';
            } else {
                backgroundContainer.style.opacity = '0';
                stopSprinkleEffect();
                aboutBtn.style.display = 'none';
            }
        }
        
        playBtn.addEventListener('click', () => showScreen('play-screen'));
        makeBtn.addEventListener('click', () => showScreen('make-screen'));
        aboutBtn.addEventListener('click', () => showScreen('about-screen'));
        playBackBtn.addEventListener('click', () => showScreen('title-screen'));
        makeBackBtn.addEventListener('click', () => showScreen('title-screen'));
        aboutBackBtn.addEventListener('click', () => showScreen('title-screen'));

        // --- Background Effects ---
        function startSprinkleEffect() {
            if (sprinkleInterval) return;
            backgroundContainer.innerHTML = ''; 

            const MIN_DISTANCE = 100;
            const K = 30;
            const width = window.innerWidth;
            const height = window.innerHeight;
            const cellSize = MIN_DISTANCE / Math.sqrt(2);
            const gridWidth = Math.ceil(width / cellSize);
            const gridHeight = Math.ceil(height / cellSize);
            const grid = new Array(gridWidth * gridHeight);
            const active = [];
            const samples = [];
            let lightableSprinkles = [];

            function isValid(x, y) {
                if (x < 0 || x >= width || y < 0 || y >= height) return false;
                const col = Math.floor(x / cellSize);
                const row = Math.floor(y / cellSize);
                const startX = Math.max(0, col - 2);
                const endX = Math.min(gridWidth - 1, col + 2);
                const startY = Math.max(0, row - 2);
                const endY = Math.min(gridHeight - 1, row + 2);

                for (let i = startY; i <= endY; i++) {
                    for (let j = startX; j <= endX; j++) {
                        const neighbor = grid[i * gridWidth + j];
                        if (neighbor) {
                            const dx = neighbor.x - x;
                            const dy = neighbor.y - y;
                            if (dx * dx + dy * dy < MIN_DISTANCE * MIN_DISTANCE) return false;
                        }
                    }
                }
                return true;
            }
            
            const p0 = {x: Math.random() * width, y: Math.random() * height};
            const col0 = Math.floor(p0.x / cellSize);
            const row0 = Math.floor(p0.y / cellSize);
            grid[row0 * gridWidth + col0] = p0;
            active.push(p0);
            samples.push(p0);

            while (active.length > 0) {
                const randomIndex = Math.floor(Math.random() * active.length);
                const p = active[randomIndex];
                let found = false;
                for (let i = 0; i < K; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = Math.random() * MIN_DISTANCE + MIN_DISTANCE;
                    const x = p.x + Math.cos(angle) * radius;
                    const y = p.y + Math.sin(angle) * radius;
                    if (isValid(x, y)) {
                        const newPoint = {x: x, y: y};
                        const col = Math.floor(x / cellSize);
                        const row = Math.floor(y / cellSize);
                        grid[row * gridWidth + col] = newPoint;
                        active.push(newPoint);
                        samples.push(newPoint);
                        found = true;
                    }
                }
                if (!found) active.splice(randomIndex, 1);
            }

            samples.forEach(point => {
                 const sprinkle = document.createElement('div');
                 sprinkle.classList.add('sprinkle');
                 sprinkle.style.left = `${point.x}px`;
                 sprinkle.style.top = `${point.y}px`;
                 sprinkle.style.setProperty('--rotation', `${Math.random() * 360}deg`);
                 backgroundContainer.appendChild(sprinkle);
            });
            
            const contentBox = document.getElementById('title-content-box');
            if (contentBox) {
                const contentBoxRect = contentBox.getBoundingClientRect();
                lightableSprinkles = Array.from(backgroundContainer.children).filter(sprinkle => {
                    const sprinkleRect = sprinkle.getBoundingClientRect();
                    return !(sprinkleRect.left < contentBoxRect.right &&
                             sprinkleRect.right > contentBoxRect.left &&
                             sprinkleRect.top < contentBoxRect.bottom &&
                             sprinkleRect.bottom > contentBoxRect.top);
                });
            } else {
                lightableSprinkles = Array.from(backgroundContainer.children);
            }

            sprinkleInterval = setInterval(() => {
                if (lightableSprinkles.length > 0) {
                    const randomSprinkle = lightableSprinkles[Math.floor(Math.random() * lightableSprinkles.length)];
                    const randomColorVar = COLOR_VALUES[Math.floor(Math.random() * COLOR_VALUES.length)];
                    randomSprinkle.style.backgroundColor = getCssVariable(randomColorVar);
                    setTimeout(() => {
                        randomSprinkle.style.backgroundColor = getCssVariable('--sprinkle-color-off');
                    }, 1500); 
                }
            }, 300);
        }

        function stopSprinkleEffect() {
            clearInterval(sprinkleInterval);
            sprinkleInterval = null;
        }

        // --- Puzzle Maker & Cipher Logic ---
        function setupMakerGrid() {
             for (let i = 0; i < 4; i++) {
                document.getElementById(`cat-${i}-name`).classList.add(`category-${i}`);
            }
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.classList.add('maker-input', `category-${i}`);
                    input.id = `word-${i}-${j}`;
                    input.placeholder = ``; // Placeholder set dynamically
                    makerGrid.appendChild(input);
                }
            }
        }
        
        function setupDynamicPlaceholders() {
            for (let i = 0; i < 4; i++) {
                const categoryNameInput = document.getElementById(`cat-${i}-name`);
                categoryNameInput.addEventListener('input', (e) => {
                    const categoryName = e.target.value.trim();
                    for (let j = 0; j < 4; j++) {
                        const wordInput = document.getElementById(`word-${i}-${j}`);
                        if (wordInput) {
                            wordInput.placeholder = categoryName || `Category ${i + 1}`;
                        }
                    }
                });
                categoryNameInput.dispatchEvent(new Event('input'));
            }
        }
        
        addTitleBtn.addEventListener('click', () => {
            optionalFields.style.display = 'flex';
            addTitleBtn.style.display = 'none';
        });

        function caesarCipher(str, shift, decrypt = false) {
            return str.replace(/[a-zA-Z\s]/g, (char) => {
                if (char === ' ') return ' ';
                const base = char < 'a' ? 'A'.charCodeAt(0) : 'a'.charCodeAt(0);
                let code = char.charCodeAt(0);
                let shiftedCode;
                if (decrypt) {
                    shiftedCode = code - base - shift;
                    if (shiftedCode < 0) shiftedCode += 26;
                } else {
                    shiftedCode = code - base + shift;
                }
                return String.fromCharCode(base + (shiftedCode % 26));
            });
        }
        
        generateJsonBtn.addEventListener('click', () => {
             const title = puzzleTitleInput.value.trim();
             const author = puzzleAuthorInput.value.trim();
             const puzzle = { categories: [], shift: 0 };
             if (title) puzzle.title = title;
             if (author) puzzle.author = author;

             const shift = Math.floor(Math.random() * 21) + 5;
             puzzle.shift = shift;

             if (puzzle.title) puzzle.title = caesarCipher(puzzle.title.toUpperCase(), shift);
             if (puzzle.author) puzzle.author = caesarCipher(puzzle.author.toUpperCase(), shift);
             
             const allWords = new Set();

             for (let i = 0; i < 4; i++) {
                 const categoryName = document.getElementById(`cat-${i}-name`).value.trim();
                 if (!categoryName) {
                     displayMessage(`Please enter a name for Category ${i + 1}.`);
                     return;
                 }
                 const words = [];
                 for (let j = 0; j < 4; j++) {
                     const word = document.getElementById(`word-${i}-${j}`).value.trim();
                     if (!word) {
                         displayMessage(`Please enter all four words for Category ${i + 1}.`);
                         return;
                     }
                     if (allWords.has(word.toUpperCase())) {
                         displayMessage(`Duplicate term found: "${word}". All 16 words must be unique.`);
                         return;
                     }
                     allWords.add(word.toUpperCase());
                     words.push(caesarCipher(word.toUpperCase(), shift));
                 }
                 puzzle.categories.push({
                     level: i, name: caesarCipher(categoryName.toUpperCase(), shift), words: words
                 });
             }
             const prefix = "Copy and paste this code into Connectionsish: ";
             const jsonString = JSON.stringify(puzzle);
             jsonOutput.value = prefix + jsonString;

             const encodedData = btoa(jsonString);
             urlOutput.value = `https://rockhopperhd.github.io/connectionsish/#${encodedData}`;
             urlOutput.style.display = 'block';
             copyLinkBtn.style.display = 'inline-flex';

             displayMessage('Code & Link generated!', getCssVariable('--cat-green'));
        });
        
        copyCodeBtn.addEventListener('click', () => {
            if (!jsonOutput.value) { displayMessage("Please generate the code first."); return; }
            jsonOutput.select();
            try {
                document.execCommand('copy');
                copyCodeBtn.textContent = 'Copied!';
                setTimeout(() => { copyCodeBtn.textContent = 'Copy Code'; }, 2000);
                displayMessage('Code copied to clipboard!', getCssVariable('--cat-green'));
            } catch (err) {
                console.error('Failed to copy code: ', err);
                displayMessage('Failed to copy. Please copy manually.');
            }
        });

        copyLinkBtn.addEventListener('click', () => {
             if (!urlOutput.value) { displayMessage("Please generate the code first."); return; }
            urlOutput.select();
            try {
                document.execCommand('copy');
                copyLinkBtn.textContent = 'Copied!';
                setTimeout(() => { copyLinkBtn.textContent = 'Copy Link'; }, 2000);
                displayMessage('Link copied to clipboard!', getCssVariable('--cat-green'));
            } catch (err) {
                console.error('Failed to copy link: ', err);
                displayMessage('Failed to copy. Please copy manually.');
            }
        });

        function startGameFromData(puzzleData) {
            try {
                if (!puzzleData.categories || typeof puzzleData.shift === 'undefined') {
                    throw new Error("Invalid puzzle data structure.");
                }
                
                gameData = { categories: [] };
                if (puzzleData.title) gameData.title = caesarCipher(puzzleData.title, puzzleData.shift, true);
                if (puzzleData.author) gameData.author = caesarCipher(puzzleData.author, puzzleData.shift, true);

                puzzleData.categories.forEach(cat => {
                    gameData.categories.push({
                        level: cat.level,
                        name: caesarCipher(cat.name, puzzleData.shift, true),
                        words: cat.words.map(w => caesarCipher(w, puzzleData.shift, true))
                    });
                });

                showScreen('game-wrapper');
                initGame();
                return true;
            } catch (e) {
                console.error(e);
                return false;
            }
        }

        startGameBtn.addEventListener('click', () => {
            if (!jsonInput.value.trim()) {
                displayMessage("Please paste puzzle code.");
                return;
            }
            let rawJson = jsonInput.value;
            const prefix = "Copy and paste this code into Connectionsish: ";
            if (rawJson.startsWith(prefix)) {
                rawJson = rawJson.substring(prefix.length);
            }
            try {
                const puzzleData = JSON.parse(rawJson);
                if (!startGameFromData(puzzleData)) {
                    displayMessage("Invalid puzzle code. Please check and try again.");
                }
            } catch {
                displayMessage("Invalid puzzle code format.");
            }
        });

        useDefaultBtn.addEventListener('click', () => {
            gameData = JSON.parse(JSON.stringify(DEFAULT_GAME_DATA)); 
            showScreen('game-wrapper');
            initGame();
        });

        continuePlayingBtn.addEventListener('click', () => {
            isEndlessMode = true;
            outOfLivesModal.classList.remove('show');
        });

        revealAnswersBtn.addEventListener('click', () => {
            outOfLivesModal.classList.remove('show');
            endGame(false);
        });

        // --- Game Initialization ---
        function initGame() {
            if (!gameData) return;
            tiles = []; selectedTiles = []; solvedCategories = []; guessHistory = []; emojiHistory = [];
            mistakesLeft = 4; extraMistakes = 0; isEndlessMode = false; isAnimating = false;
            messageBox.textContent = ''; resultsModal.classList.remove('show'); renderHistory();

            puzzleInfo.innerHTML = '';
            if (gameData.title) {
                let authorText = gameData.author ? ` by ${gameData.author}` : '';
                puzzleInfo.innerHTML = `"${gameData.title.toUpperCase()}"${authorText}
                    <div class="info-tooltip-container">
                        <span class="info-icon">i</span>
                        <span class="info-tooltip-text">This information is user-supplied and has not been verified.</span>
                    </div>`;
            }
            gamePrompt.textContent = "Make 4 groups of 4!";

            const allWords = gameData.categories.flatMap(cat => cat.words);
            shuffleArray(allWords);
            
            allWords.forEach(word => {
                tiles.push({
                    word: word, x: 0, y: 0, width: 0, height: 0,
                    targetX: 0, targetY: 0, targetWidth: 0, targetHeight: 0,
                    isSelected: false, isSolved: false, isHidden: false,
                    solvedCategory: null, shake: 0
                });
            });

            setupCanvas(); updateMistakeDots(); calculateLayout();
            if(!animationLoop.frame) animationLoop();
        }

        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- Layout and Drawing ---
        function calculateLayout() {
            const solvedCount = solvedCategories.length;
            const unsolvedTiles = tiles.filter(t => !t.isSolved);
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;
            const tileWidth = (canvasWidth - TILE_GAP * (GRID_SIZE - 1)) / GRID_SIZE;
            const tileHeight = (canvasHeight - TILE_GAP * (GRID_SIZE - 1)) / GRID_SIZE;
            
            solvedCategories.forEach((cat, catIndex) => {
                const solvedY = catIndex * (tileHeight + TILE_GAP);
                const primaryTile = tiles.find(t => cat.words.includes(t.word) && !t.isHidden);
                if (primaryTile) {
                    primaryTile.targetX = 0;
                    primaryTile.targetY = solvedY;
                    primaryTile.targetWidth = canvasWidth;
                    primaryTile.targetHeight = tileHeight;
                }
            });

            const unsolvedAreaYOffset = solvedCount * (tileHeight + TILE_GAP);
            unsolvedTiles.forEach((tile, index) => {
                const row = Math.floor(index / GRID_SIZE);
                const col = index % GRID_SIZE;
                tile.targetWidth = tileWidth;
                tile.targetHeight = tileHeight;
                tile.targetX = col * (tileWidth + TILE_GAP);
                tile.targetY = unsolvedAreaYOffset + row * (tileHeight + TILE_GAP);
                if (tile.x === 0 && tile.y === 0) {
                    tile.x = tile.targetX; tile.y = tile.targetY;
                    tile.width = tile.targetWidth; tile.height = tile.targetHeight;
                }
            });
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
            tiles.forEach(tile => {
                if (tile.isHidden) return;
                tile.x += (tile.targetX - tile.x) * 0.1;
                tile.y += (tile.targetY - tile.y) * 0.1;
                tile.width += (tile.targetWidth - tile.width) * 0.1;
                tile.height += (tile.targetHeight - tile.height) * 0.1;
                if (tile.shake > 0) tile.shake--;
                const shakeOffsetX = Math.sin(tile.shake * 0.5) * (tile.shake / 5);
                if(tile.isSolved) drawSolvedTile(tile);
                else drawUnsolvedTile(tile, shakeOffsetX);
            });
        }
        
        function drawUnsolvedTile(tile, shakeOffsetX = 0) {
            ctx.fillStyle = tile.isSelected ? getCssVariable('--color-tile-selected') : getCssVariable('--color-tile');
            ctx.beginPath();
            ctx.roundRect(tile.x + shakeOffsetX, tile.y, tile.width, tile.height, TILE_ROUNDING);
            ctx.fill();

            const maxTextWidth = tile.width - (TILE_GAP * 1.5); 
            let fontSize = tile.height * FONT_SIZE_FACTOR;
            const fontFamily = getComputedStyle(document.body).fontFamily;
            ctx.font = `600 ${fontSize}px ${fontFamily}`;
            let textWidth = ctx.measureText(tile.word).width;
            while (textWidth > maxTextWidth && fontSize > MIN_FONT_SIZE) {
                fontSize--;
                ctx.font = `600 ${fontSize}px ${fontFamily}`;
                textWidth = ctx.measureText(tile.word).width;
            }
            
            ctx.fillStyle = getCssVariable('--color-text');
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(tile.word, tile.x + tile.width / 2 + shakeOffsetX, tile.y + tile.height / 2);
        }
        
        function drawSolvedTile(tile) {
            const color = getCssVariable(CATEGORY_COLORS[tile.solvedCategory.level]);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.roundRect(tile.x, tile.y, tile.width, tile.height, TILE_ROUNDING);
            ctx.fill();
            ctx.fillStyle = '#000000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const categoryFontSize = tile.height * FONT_SIZE_FACTOR * 0.9;
            ctx.font = `700 ${categoryFontSize}px ${getComputedStyle(document.body).fontFamily}`;
            ctx.fillText(tile.solvedCategory.name, tile.x + tile.width / 2, tile.y + tile.height / 2 - categoryFontSize * 0.6);
            const wordsFontSize = tile.height * (FONT_SIZE_FACTOR * 0.8 * 0.9);
            ctx.font = `500 ${wordsFontSize}px ${getComputedStyle(document.body).fontFamily}`;
            ctx.fillText(tile.solvedCategory.words.join(', '), tile.x + tile.width / 2, tile.y + tile.height / 2 + wordsFontSize * 0.8);
        }

        function animationLoop() {
            draw();
            animationLoop.frame = requestAnimationFrame(animationLoop);
        }
        animationLoop.frame = null;

        canvas.addEventListener('click', (e) => {
            if (isAnimating || (isGameOver() && !isEndlessMode)) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            for (let i = tiles.length - 1; i >= 0; i--) {
                const tile = tiles[i];
                if (!tile.isSolved && !tile.isHidden && x >= tile.x && x <= tile.x + tile.width && y >= tile.y && y <= tile.y + tile.height) {
                    toggleTileSelection(tile);
                    break;
                }
            }
        });

        shuffleBtn.addEventListener('click', () => {
             if (isAnimating || (isGameOver() && !isEndlessMode)) return;
             const unsolvedTiles = tiles.filter(t => !t.isSolved);
             shuffleArray(unsolvedTiles);
             let unsolvedIndex = 0;
             for (let i = 0; i < tiles.length; i++) {
                 if (!tiles[i].isSolved) tiles[i] = unsolvedTiles[unsolvedIndex++];
             }
             calculateLayout();
        });

        deselectBtn.addEventListener('click', deselectAll);
        submitBtn.addEventListener('click', handleSubmit);
        playAgainBtn.addEventListener('click', () => {
            resultsModal.classList.remove('show');
            if(animationLoop.frame) {
                cancelAnimationFrame(animationLoop.frame);
                animationLoop.frame = null;
            }
            showScreen('title-screen');
        });
        copyResultsBtn.addEventListener('click', copyResultsToClipboard);
        window.addEventListener('resize', () => {
            if (gameData) { setupCanvas(); calculateLayout(); }
        });
        historyTab.addEventListener('click', (e) => {
            e.stopPropagation();
            historyPanel.classList.toggle('is-open');
        });
        document.addEventListener('click', (e) => {
            if(historyPanel.classList.contains('is-open') && !historyPanel.contains(e.target)) {
                historyPanel.classList.remove('is-open');
            }
        });


        // --- Game Logic ---
        function toggleTileSelection(tile) {
            if (tile.isSelected) {
                tile.isSelected = false;
                selectedTiles = selectedTiles.filter(t => t.word !== tile.word);
            } else if (selectedTiles.length < 4) {
                tile.isSelected = true;
                selectedTiles.push(tile);
            }
        }

        function deselectAll() {
            if (isAnimating || (isGameOver() && !isEndlessMode)) return;
            selectedTiles.forEach(tile => tile.isSelected = false);
            selectedTiles = [];
        }

        function handleSubmit() {
            if (isAnimating || selectedTiles.length !== 4 || (isGameOver() && !isEndlessMode)) return;
            const selectedWords = selectedTiles.map(t => t.word).sort();
            if (guessHistory.some(g => g.words.slice().sort().join(',') === selectedWords.join(','))) {
                displayMessage('Already guessed!');
                return;
            }
            const foundCategory = gameData.categories.find(c =>
                c.words.every(w => selectedWords.includes(w)) && selectedWords.every(w => c.words.includes(w))
            );
            if (foundCategory) handleCorrectGuess(foundCategory);
            else handleIncorrectGuess();
        }

        function handleCorrectGuess(category) {
            isAnimating = true;
            solvedCategories.push(category);
            guessHistory.push({ words: category.words, correct: true });
            emojiHistory.push(Array(4).fill(CATEGORY_COLORS[category.level]));
            renderHistory();
            displayMessage('Correct!', getCssVariable('--cat-green'));
            
            const tileWidth = (canvas.clientWidth - TILE_GAP * (GRID_SIZE - 1)) / GRID_SIZE;
            const tileHeight = (canvas.clientHeight - TILE_GAP * (GRID_SIZE - 1)) / GRID_SIZE;
            const targetY = (solvedCategories.length - 1) * (tileHeight + TILE_GAP);
            const sortedSelection = selectedTiles.sort((a, b) => a.x - b.x);
            sortedSelection.forEach((tile, index) => {
                tile.isSelected = false; tile.targetX = index * (tileWidth + TILE_GAP); tile.targetY = targetY;
            });
            const primaryTile = sortedSelection[0];
            const otherTiles = sortedSelection.slice(1);
            setTimeout(() => {
                otherTiles.forEach(tile => { tile.isHidden = true; tile.isSolved = true; });
                primaryTile.isSolved = true; primaryTile.solvedCategory = category; selectedTiles = [];
                calculateLayout();
                const finalWidth = primaryTile.targetWidth, finalHeight = primaryTile.targetHeight;
                primaryTile.targetWidth = finalWidth * 1.05; primaryTile.targetHeight = finalHeight * 1.15;
                setTimeout(() => {
                    primaryTile.targetWidth = finalWidth; primaryTile.targetHeight = finalHeight;
                    setTimeout(() => {
                        isAnimating = false; 
                        if (isGameWon()) endGame(true);
                    }, 300);
                }, 120);
            }, 400);
        }
        
        function handleIncorrectGuess() {
            if(isEndlessMode) {
                extraMistakes++;
            } else {
                mistakesLeft--;
                updateMistakeDots();
            }
            
            const selectedWords = selectedTiles.map(t => t.word);
            selectedTiles.forEach(tile => tile.shake = 20);
            let isOneAway = false;
            for(const cat of gameData.categories) {
                if (solvedCategories.includes(cat)) continue;
                if(selectedWords.filter(t => cat.words.includes(t)).length === 3) {
                    isOneAway = true;
                    break;
                }
            }
            guessHistory.push({ words: selectedWords, oneAway: isOneAway, correct: false });
            emojiHistory.push(selectedWords.map(w => CATEGORY_COLORS[gameData.categories.find(c => c.words.includes(w)).level]));
            renderHistory();
            if (isOneAway) displayMessage('One away...');
            
            if (mistakesLeft <= 0 && !isEndlessMode) {
                outOfLivesModal.classList.add('show');
            }
        }

        function displayMessage(text, color) {
            messageBox.textContent = text;
            messageBox.style.color = color || getCssVariable('--color-text');
            messageBox.classList.add('show');
            setTimeout(() => { messageBox.classList.remove('show'); }, 2000);
        }

        function updateMistakeDots() {
            mistakesContainer.innerHTML = '<span>Mistakes remaining:</span>';
            for (let i = 0; i < 4; i++) {
                const dot = document.createElement('div');
                dot.classList.add('mistake-dot');
                if (i >= mistakesLeft) dot.classList.add('used');
                mistakesContainer.appendChild(dot);
            }
        }
        
        function renderHistory() {
            historyContent.innerHTML = '';
            [...guessHistory].reverse().forEach(guess => {
                const el = document.createElement('div');
                el.classList.add('history-guess');
                if (guess.correct) el.classList.add('correct');
                el.textContent = guess.words.join(', ');
                if (guess.oneAway) {
                    const icon = document.createElement('span');
                    icon.classList.add('one-away-icon');
                    icon.textContent = '!';
                    icon.title = 'One away!';
                    el.appendChild(icon);
                }
                historyContent.appendChild(el);
            });
        }

        // --- Game End ---
        function isGameOver() { return mistakesLeft <= 0; }
        function isGameWon() { return solvedCategories.length === gameData.categories.length; }

        function endGame(isWin) {
            isAnimating = true;
            setTimeout(() => {
                resultsTitle.textContent = isWin ? "Congratulations!" : "Next Time!";
                resultsMessage.textContent = isWin ? "You found all the connections!" : "Here are the answers:";
                if (!isWin) {
                    const unsolved = gameData.categories.filter(c => !solvedCategories.find(sc => sc.name === c.name));
                    solvedCategories.push(...unsolved);
                }
                resultsGrid.innerHTML = '';
                const finalDisplay = [...solvedCategories].sort((a,b) => a.level - b.level);
                finalDisplay.forEach(cat => {
                    const row = document.createElement('div');
                    row.classList.add('result-row');
                    row.style.backgroundColor = getCssVariable(CATEGORY_COLORS[cat.level]);
                    row.innerHTML = `<strong>${cat.name}</strong><span>${cat.words.join(', ')}</span>`;
                    resultsGrid.appendChild(row);
                });
                resultsModal.classList.add('show');
            }, 1200);
        }
        
        function generateEmojiString() {
            const emojiMap = { '--cat-yellow': '', '--cat-green': '', '--cat-blue': '', '--cat-purple': '' };
            let result = `Connectionsish: "${gameData.title || 'Custom Puzzle'}"\n`;
            result += emojiHistory.map(row => row.map(color => emojiMap[color] || '').join('')).join('\n');
            if (isGameWon() && extraMistakes === 0) {
                result += `\n ${mistakesLeft} left`;
            } else if (extraMistakes > 0) {
                result += `\n +${extraMistakes}`;
            }
            return result;
        }
        
        function copyResultsToClipboard() {
            const resultString = generateEmojiString();
            const textArea = document.createElement('textarea');
            textArea.value = resultString;
            textArea.style.position = 'fixed'; 
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                copyResultsBtn.textContent = 'Copied!';
                setTimeout(() => { copyResultsBtn.textContent = 'Share'; }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
                copyResultsBtn.textContent = 'Failed!';
                setTimeout(() => { copyResultsBtn.textContent = 'Share'; }, 2000);
            }
            document.body.removeChild(textArea);
        }
        
        function getCssVariable(variable) {
            return getComputedStyle(document.documentElement).getPropertyValue(variable).trim();
        }

        // --- Start App ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("%cHello World!", "font-size: 50px; color: #f9df6d; text-shadow: 2px 2px 0 #d0b0ef, 4px 4px 0 #b0c4ef, 6px 6px 0 #a0c35a;");
            setupMakerGrid();
            setupDynamicPlaceholders();
            
            const detailsElements = document.querySelectorAll('.q-a-container details');
            detailsElements.forEach(details => {
                details.addEventListener('toggle', () => {
                    if (details.open) {
                        detailsElements.forEach(otherDetails => {
                            if (otherDetails !== details) {
                                otherDetails.open = false;
                            }
                        });
                    }
                });
            });

            // Auto-play from URL hash
            if (window.location.hash && window.location.hash.length > 1) {
                try {
                    const encodedData = window.location.hash.substring(1);
                    const jsonString = atob(encodedData);
                    const puzzleData = JSON.parse(jsonString);
                    if (startGameFromData(puzzleData)) {
                        return; // Successfully started from URL, skip title screen
                    }
                } catch(e) {
                    console.error("Failed to load puzzle from URL hash:", e);
                }
            }

            showScreen('title-screen');
        });

    </script>
</body>
</html>

